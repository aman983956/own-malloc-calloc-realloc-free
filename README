1. What is Memory Alignment?
Memory alignment means storing data in memory at addresses that are multiples of the data’s size or alignment requirement.

For example:
A 4-byte int → should start at a multiple of 4 (like 0, 4, 8, 12…)
An 8-byte double → should start at a multiple of 8 (like 0, 8, 16, 24…)

2. Why is Alignment Necessary?
There are two main reasons — performance and hardware design.

 (a) CPU Performance
	Modern CPUs fetch data from memory in chunks (words) — often 4 or 8 bytes at a time.
	If a variable starts at a properly aligned address (e.g. multiple of 8 for 8-byte data), The CPU can fetch the entire value in one read.
	If it’s misaligned (say starts at address 6), The value might span across two chunks, forcing the CPU to do two memory reads and combine them slower.
	
	So alignment makes memory access: Faster, Simpler, More predictable


 (b) Hardware Restriction
	Some CPU architectures (like ARM, SPARC, older MIPS) cannot access unaligned addresses at all.
	If a program tries to read a 4-byte int at address 0x0003, the CPU might raise a “bus error” or “alignment fault” — and crash.
	So, alignment isn’t just performance — it’s also safety and compatibility.

3. Why specifically multiple of 8?
	Because 8 bytes (64 bits) is the natural word size of modern 64-bit CPUs.

	That means:
		The CPU’s registers and data bus are 8 bytes wide.
		It can read/write 8 bytes in one operation.

	Hence, aligning data to 8-byte boundaries allows the CPU to:
		Access 64-bit data in a single instruction.
		Avoid crossing memory boundaries.

	Note : Natural size of 64-bit CPU word, so alignment is based on 8.


====================================================================================================================================================


macro ALIGNMENT
------------------
macro ALIGNMENT means we want every memory address (or size) to be a multiple of 8 bytes.
The starting address of a variable (or the size of a memory block) should be evenly divisible by 8 — like 0, 8, 16, 24, 32...
Because CPUs access memory faster and more safely when data is stored at aligned addresses.


macro ALIGN_UP 
-----------------
The macro ALIGN_UP ensures any number (like a memory size or address) is adjusted upward to the next multiple of 8 bytes — useful for memory alignment.


====================================================================================================================================================

Q. If I allocate 20 byte memory using malloc so I will get only 20 bytes of memory or it will different in size.

Ans. 

1) What you request vs. what you actually get
	When you call: void *ptr = malloc(20);

   you request 20 bytes of memory from the heap. However, you do not necessarily get exactly 20 bytes of memory allocated at the system level — you just get a pointer to a usable block of at least 20 bytes.

   The actual allocated size can be larger for several reasons.


2) Why the allocated size may be larger
   
   Alignment requirements

      a. Most systems require allocated memory to be aligned to certain byte boundaries (for performance and correctness).
      b. Common alignments are 8 bytes (on 64-bit systems) or sometimes 16 bytes.
      c. So, if you ask for 20 bytes, the allocator might round that up to 24 or 32 bytes internally.

   
   Metadata overhead

      a. The memory allocator (like glibc’s ptmalloc) stores some bookkeeping information about each block — such as its size and links to other blocks.
      b. This metadata is usually stored in memory just before your returned pointer.
      c. So if you call malloc(20), the total memory consumed by the allocator could be something like:
	   Ex : [metadata (8–16 bytes)] + [your 20-byte usable block] + [possible padding]


   Allocator granularity / block size

      a. Many allocators manage memory in fixed-size chunks or bins (e.g., 16, 32, 64 bytes...).
      b. So if you ask for 20 bytes, the allocator may give you a 32-byte block because that’s the smallest available bucket.


Example on a typical system :

#include <malloc.h>
#include <stdio.h>

int main(void) {
    void *p = malloc(20);
    printf("Allocated pointer: %p\n", p);
    printf("Usable size: %zu\n", malloc_usable_size(p)); // Linux-specific
    free(p);
}

On a 64-bit Linux system, you might see something like: 

	Usable size: 24
	     or
	Usable size: 32


This shows that while you requested 20 bytes, you got a block of 24 or 32 bytes usable memory (depending on allocator internals).


Summary :
----------------------------------------------------------------------
| Concept                | Description                               |
----------------------------------------------------------------------
| You requested          | 20 bytes                                  |
| You’re guaranteed      | At least 20 bytes usable                  |
| You might actually get | 24, 32, or another rounded-up size        |
| Reason                 | Alignment + metadata + allocator strategy |
----------------------------------------------------------------------

